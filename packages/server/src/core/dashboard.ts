import { statSync, existsSync, readFileSync, writeFileSync, mkdirSync } from "fs";
import { basename, join } from "path";
import { homedir } from "os";
import { getActiveSessions, listProjects, listSessions } from "../discovery/sessions.js";
import { getActiveCodexSessions, discoverCodexSessions } from "../discovery/codex.js";
import { parseSessionFile, parseSystemLines } from "../parser/jsonl.js";
import { parseCodexSessionFile } from "../parser/codex.js";
import { buildParsedSession } from "./nodes.js";
import { buildCodexParsedSession } from "./codex-nodes.js";
import { detectCollisions } from "./collisions.js";
import { buildFeed } from "./feed.js";
import { computeAgentRisk, computeWorkstreamRisk } from "./risk.js";
import { computeTurnCost } from "./pricing.js";
import { loadOperatorConfig, getSelfName, operatorId as makeOperatorId, getOperatorColor } from "./config.js";
import type {
  ParsedSession, SessionInfo, Agent, AgentStatus,
  Workstream, DashboardState, DashboardSummary, Operator,
  SessionPlan, PlanStatus, PlanTask, TokenUsage, DraftingActivity,
} from "../types/index.js";

// ─── In-memory parse cache ──────────────────────────────────────────────────

interface CacheEntry {
  mtimeMs: number;
  parsed: ParsedSession;
}

const parseCache = new Map<string, CacheEntry>();

// ─── Session accumulator — survives compaction ──────────────────────────────

interface SessionAccumulator {
  totalTurns: number;
  totalToolCalls: number;
  totalCommits: number;
  totalCompactions: number;
  totalErrorTurns: number;
  totalCorrectionTurns: number;
  totalTokenUsage: TokenUsage;
  filesChanged: Set<string>;
  toolsUsed: Record<string, number>;
  primaryModel: string | null;
  plans: SessionPlan[];
  errorHistory: boolean[];
  totalCost: number;
}

const accumulators = new Map<string, SessionAccumulator>();

// ─── Accumulator helpers ─────────────────────────────────────────────────────

function maxTokenUsage(a: TokenUsage | undefined, b: TokenUsage): TokenUsage {
  if (!a) return { ...b };
  return {
    inputTokens: Math.max(a.inputTokens, b.inputTokens),
    outputTokens: Math.max(a.outputTokens, b.outputTokens),
    cacheReadInputTokens: Math.max(a.cacheReadInputTokens, b.cacheReadInputTokens),
    cacheCreationInputTokens: Math.max(a.cacheCreationInputTokens, b.cacheCreationInputTokens),
  };
}

function addTokenUsage(a: TokenUsage, b: TokenUsage): TokenUsage {
  return {
    inputTokens: a.inputTokens + b.inputTokens,
    outputTokens: a.outputTokens + b.outputTokens,
    cacheReadInputTokens: a.cacheReadInputTokens + b.cacheReadInputTokens,
    cacheCreationInputTokens: a.cacheCreationInputTokens + b.cacheCreationInputTokens,
  };
}

function unionSets(a: Set<string> | undefined, b: Set<string>): Set<string> {
  if (!a) return new Set(b);
  return new Set([...a, ...b]);
}

function mergeToolsUsed(
  a: Record<string, number> | undefined,
  b: Record<string, number>
): Record<string, number> {
  if (!a) return { ...b };
  const merged = { ...a };
  for (const [tool, count] of Object.entries(b)) {
    merged[tool] = Math.max(merged[tool] ?? 0, count);
  }
  return merged;
}

const AGENT_NAMES = [
  "neo", "morpheus", "trinity", "oracle", "cypher", "tank", "dozer", "switch",
  "apoc", "mouse", "niobe", "link", "ghost", "zee", "lock", "merovingian",
  "seraph", "sati", "rama", "ajax", "jue", "thadeus", "ballard", "mifune",
  "hamann", "deus", "trainman", "persephone", "keymaker", "architect",
];

function hashToIndex(id: string): number {
  let h = 0;
  for (let i = 0; i < id.length; i++) {
    h = ((h << 5) - h + id.charCodeAt(i)) | 0;
  }
  return Math.abs(h);
}

// ─── Persistent label store (survives server restarts) ───────────────────────

const PYLON_DIR = join(homedir(), ".pylon");
const LABELS_PATH = join(PYLON_DIR, "labels.json");

interface LabelEntry {
  name: string;
  lastSeen: number; // epoch ms
}

/** In-memory mirror of the disk-backed label store */
let labelStore = new Map<string, LabelEntry>();
let labelStoreLoaded = false;

/** Max age before a label for a dead session gets garbage-collected */
const LABEL_GC_AGE_MS = 2 * 60 * 60 * 1000; // 2 hours

function loadLabelStore(): void {
  if (labelStoreLoaded) return;
  labelStoreLoaded = true;
  try {
    if (!existsSync(LABELS_PATH)) return;
    const raw = JSON.parse(readFileSync(LABELS_PATH, "utf-8"));
    if (raw && typeof raw === "object") {
      for (const [id, entry] of Object.entries(raw)) {
        if (entry && typeof entry === "object" && "name" in (entry as Record<string, unknown>)) {
          const e = entry as LabelEntry;
          labelStore.set(id, { name: e.name, lastSeen: e.lastSeen ?? 0 });
        }
      }
    }
  } catch {
    // Corrupt file — start fresh
    labelStore = new Map();
  }
}

function saveLabelStore(): void {
  try {
    if (!existsSync(PYLON_DIR)) mkdirSync(PYLON_DIR, { recursive: true });
    const obj: Record<string, LabelEntry> = {};
    for (const [id, entry] of labelStore) {
      obj[id] = entry;
    }
    writeFileSync(LABELS_PATH, JSON.stringify(obj, null, 2));
  } catch {
    // Non-critical — labels will still work in-memory
  }
}

/**
 * Assign unique short names. Persisted to disk so names survive restarts.
 * Dead sessions' names are reclaimed after LABEL_GC_AGE_MS.
 */
function buildLabelMap(sessionIds: string[]): Map<string, string> {
  loadLabelStore();

  const now = Date.now();
  const currentIds = new Set(sessionIds);

  // 1. Garbage-collect: remove labels for sessions not seen recently
  for (const [id, entry] of labelStore) {
    if (!currentIds.has(id) && now - entry.lastSeen > LABEL_GC_AGE_MS) {
      labelStore.delete(id);
    }
  }

  // 2. Touch all current sessions
  for (const id of sessionIds) {
    const existing = labelStore.get(id);
    if (existing) {
      existing.lastSeen = now;
    }
  }

  // 3. Build the set of names currently in use (only by live or recent sessions)
  const usedNames = new Set<string>();
  for (const entry of labelStore.values()) {
    usedNames.add(entry.name);
  }

  // 4. Assign names to new sessions
  let dirty = false;
  for (const id of sessionIds) {
    if (labelStore.has(id)) continue;

    let idx = hashToIndex(id) % AGENT_NAMES.length;
    let name = AGENT_NAMES[idx];

    // Resolve collisions
    let attempt = 0;
    while (usedNames.has(name)) {
      attempt++;
      idx = (idx + 1) % AGENT_NAMES.length;
      if (attempt >= AGENT_NAMES.length) {
        name = AGENT_NAMES[hashToIndex(id) % AGENT_NAMES.length] + `-${attempt}`;
        break;
      }
      name = AGENT_NAMES[idx];
    }

    usedNames.add(name);
    labelStore.set(id, { name, lastSeen: now });
    dirty = true;
  }

  if (dirty) saveLabelStore();

  // 5. Return only the labels for requested session IDs
  const map = new Map<string, string>();
  for (const id of sessionIds) {
    map.set(id, labelStore.get(id)!.name);
  }
  return map;
}

function updateAccumulator(sessionId: string, parsed: ParsedSession): void {
  const prev = accumulators.get(sessionId);
  const { stats } = parsed;

  // Compute current cost from visible turns
  let currentCost = 0;
  for (const turn of parsed.turns) {
    currentCost += computeTurnCost(turn.model, turn.tokenUsage);
  }

  const acc: SessionAccumulator = {
    totalTurns: Math.max(prev?.totalTurns ?? 0, stats.totalTurns),
    totalToolCalls: Math.max(prev?.totalToolCalls ?? 0, stats.toolCalls),
    totalCommits: Math.max(prev?.totalCommits ?? 0, stats.commits),
    totalCompactions: Math.max(prev?.totalCompactions ?? 0, stats.compactions),
    totalErrorTurns: Math.max(prev?.totalErrorTurns ?? 0, stats.errorTurns),
    totalCorrectionTurns: Math.max(prev?.totalCorrectionTurns ?? 0, stats.correctionTurns),
    totalTokenUsage: maxTokenUsage(prev?.totalTokenUsage, stats.totalTokenUsage),
    filesChanged: unionSets(prev?.filesChanged, new Set(stats.filesChanged)),
    toolsUsed: mergeToolsUsed(prev?.toolsUsed, stats.toolsUsed),
    primaryModel: stats.primaryModel ?? prev?.primaryModel ?? null,
    plans: [],
    errorHistory: [],
    totalCost: Math.max(prev?.totalCost ?? 0, currentCost),
  };

  // Plans: keep all plan cycles; fall back to accumulator if current parse yields nothing
  const currentPlans = buildSessionPlans(parsed, "");
  if (currentPlans.length > 0) {
    acc.plans = currentPlans;
  } else {
    acc.plans = prev?.plans ?? [];
  }

  // Error history: extend on compaction, replace on normal growth
  const prevHistory = prev?.errorHistory ?? [];
  const currentErrors = parsed.turns.map(t => t.hasError);
  if (prev && prev.totalTurns > parsed.turns.length) {
    // Compaction: keep old history, append new post-compaction turns
    acc.errorHistory = [...prevHistory, ...currentErrors];
  } else {
    // Normal: current parse is the full history
    acc.errorHistory = currentErrors;
  }

  accumulators.set(sessionId, acc);
}

function mergeAccumulatorIntoStats(acc: SessionAccumulator, parsed: ParsedSession): void {
  // Compaction: accumulated baseline + post-compaction delta (current parse)
  parsed.stats.totalTurns = acc.totalTurns + parsed.stats.totalTurns;
  parsed.stats.toolCalls = acc.totalToolCalls + parsed.stats.toolCalls;
  parsed.stats.commits = acc.totalCommits + parsed.stats.commits;
  parsed.stats.compactions = acc.totalCompactions; // already counted
  parsed.stats.errorTurns = acc.totalErrorTurns + parsed.stats.errorTurns;
  parsed.stats.correctionTurns = acc.totalCorrectionTurns + parsed.stats.correctionTurns;
  parsed.stats.totalTokenUsage = addTokenUsage(acc.totalTokenUsage, parsed.stats.totalTokenUsage);
  parsed.stats.filesChanged = [...new Set([...acc.filesChanged, ...parsed.stats.filesChanged])];
  parsed.stats.toolsUsed = mergeToolsUsed(acc.toolsUsed, parsed.stats.toolsUsed);
  parsed.stats.primaryModel = parsed.stats.primaryModel ?? acc.primaryModel;
}

function getCachedOrParse(session: SessionInfo): ParsedSession {
  const cached = parseCache.get(session.id);
  let currentMtime: number;

  try {
    currentMtime = statSync(session.path).mtimeMs;
  } catch {
    // File may have been deleted; parse fresh
    currentMtime = 0;
  }

  if (cached && cached.mtimeMs === currentMtime) {
    return cached.parsed;
  }

  const events = parseSessionFile(session.path);
  const systemMeta = parseSystemLines(session.path);
  const parsed = buildParsedSession(session, events, systemMeta);

  // Compaction detection: accumulator had more turns than current parse
  const acc = accumulators.get(session.id);
  const isCompaction = acc && acc.totalTurns > parsed.turns.length;

  if (isCompaction) {
    mergeAccumulatorIntoStats(acc, parsed);
  }

  // Always update accumulator to reflect current state
  updateAccumulator(session.id, parsed);

  parseCache.set(session.id, { mtimeMs: currentMtime, parsed });
  return parsed;
}

// ─── Codex parse cache (separate from Claude) ───────────────────────────────

const codexParseCache = new Map<string, CacheEntry>();

function isCodexSession(session: SessionInfo): boolean {
  return session.path.includes("/.codex/");
}

function getCachedOrParseCodex(session: SessionInfo): ParsedSession {
  const cached = codexParseCache.get(session.id);
  let currentMtime: number;

  try {
    currentMtime = statSync(session.path).mtimeMs;
  } catch {
    currentMtime = 0;
  }

  if (cached && cached.mtimeMs === currentMtime) {
    return cached.parsed;
  }

  const events = parseCodexSessionFile(session.path);
  const parsed = buildCodexParsedSession(session, events);

  codexParseCache.set(session.id, { mtimeMs: currentMtime, parsed });
  return parsed;
}

// ─── Plan builder ────────────────────────────────────────────────────────────

function finalizePlan(
  tasks: PlanTask[],
  taskStatuses: Map<string, string>,
  markdown: string | null,
  inPlanMode: boolean,
  planAccepted: boolean,
  planRejected: boolean,
  agentLabel: string,
  timestamp: Date,
  planDurationMs: number | null,
  draftingActivity: DraftingActivity | null,
): SessionPlan | null {
  // Apply final statuses
  for (const task of tasks) {
    const latest = taskStatuses.get(task.id);
    if (latest === "completed" || latest === "in_progress" || latest === "pending" || latest === "deleted") {
      task.status = latest;
    }
  }

  const activeTasks = tasks.filter(t => t.status !== "deleted");

  // Determine status — tasks are the ground truth
  let status: PlanStatus = "none";

  if (activeTasks.length > 0) {
    if (activeTasks.every(t => t.status === "completed")) {
      status = "completed";
    } else if (activeTasks.some(t => t.status === "in_progress" || t.status === "completed")) {
      status = "implementing";
    } else {
      status = "drafting";
    }
  } else if (markdown || inPlanMode || planAccepted || planRejected) {
    if (planRejected) {
      status = "rejected";
    } else if (inPlanMode || planAccepted || markdown) {
      status = "drafting";
    }
  }

  if (status === "none") return null;

  // Only attach drafting activity when status is "drafting"
  const activity = status === "drafting" ? draftingActivity : null;

  return { status, markdown, tasks: activeTasks, agentLabel, timestamp, planDurationMs, draftingActivity: activity };
}

function buildSessionPlans(parsed: ParsedSession, agentLabel: string): SessionPlan[] {
  const finalized: SessionPlan[] = [];

  // Current plan cycle accumulator
  let markdown: string | null = null;
  let planAccepted = false;
  let planRejected = false;
  let inPlanMode = false;
  let lastPlanTs: Date = parsed.session.createdAt;
  let planStartTs: Date | null = null;
  let planDurationMs: number | null = null;
  let tasks: PlanTask[] = [];
  let taskStatuses = new Map<string, string>();

  // Drafting activity accumulator
  let draftFiles: Set<string> = new Set();
  let draftSearches: string[] = [];
  let draftToolCounts: Record<string, number> = {};
  let draftApproach = "";
  let draftLastActivity: Date | null = null;
  let draftTurnCount = 0;

  function resetDraftingActivity(): void {
    draftFiles = new Set();
    draftSearches = [];
    draftToolCounts = {};
    draftApproach = "";
    draftLastActivity = null;
    draftTurnCount = 0;
  }

  function buildDraftingActivity(): DraftingActivity | null {
    if (draftTurnCount === 0) return null;
    return {
      filesExplored: [...draftFiles],
      searches: draftSearches,
      toolCounts: { ...draftToolCounts },
      approachSummary: draftApproach,
      lastActivityAt: draftLastActivity!,
      turnCount: draftTurnCount,
    };
  }

  for (const turn of parsed.turns) {
    if (turn.hasPlanStart) {
      // Finalize current plan cycle (if it has any content)
      const plan = finalizePlan(tasks, taskStatuses, markdown, inPlanMode, planAccepted, planRejected, agentLabel, lastPlanTs, planDurationMs, buildDraftingActivity());
      if (plan) finalized.push(plan);

      // Start fresh cycle
      tasks = [];
      taskStatuses = new Map();
      markdown = null;
      inPlanMode = true;
      planAccepted = false;
      planRejected = false;
      lastPlanTs = turn.timestamp;
      planStartTs = turn.timestamp;
      planDurationMs = null;
      resetDraftingActivity();
    }
    if (turn.hasPlanEnd && !turn.planRejected) {
      inPlanMode = false;
      planAccepted = true;
      planRejected = false;
      markdown = turn.planMarkdown ?? markdown;
      lastPlanTs = turn.timestamp;
      if (planStartTs) {
        planDurationMs = turn.timestamp.getTime() - planStartTs.getTime();
      }
    }
    if (turn.hasPlanEnd && turn.planRejected) {
      inPlanMode = false;
      planAccepted = false;
      planRejected = true;
      lastPlanTs = turn.timestamp;
      planDurationMs = null;
    }

    // Accumulate drafting activity while in plan mode
    if (inPlanMode) {
      draftTurnCount++;
      draftLastActivity = turn.timestamp;

      for (const f of turn.filesRead) draftFiles.add(f);

      for (const s of turn.sections.research.searches) draftSearches.push(s);

      for (const [tool, count] of Object.entries(turn.toolCounts)) {
        draftToolCounts[tool] = (draftToolCounts[tool] ?? 0) + count;
      }

      if (turn.sections.approach.summary) {
        draftApproach = turn.sections.approach.summary;
      }
    }

    // Cross-session plan: planMarkdown from JSONL envelope
    if (turn.planMarkdown && !markdown) {
      markdown = turn.planMarkdown;
      lastPlanTs = turn.timestamp;
    }

    for (const tc of turn.taskCreates) {
      if (tc.taskId) {
        tasks.push({
          id: tc.taskId,
          subject: tc.subject,
          description: tc.description,
          status: "pending",
        });
        lastPlanTs = turn.timestamp;
      }
    }

    for (const tu of turn.taskUpdates) {
      taskStatuses.set(tu.taskId, tu.status);
      lastPlanTs = turn.timestamp;
    }
  }

  // Finalize the last plan cycle
  const lastPlan = finalizePlan(tasks, taskStatuses, markdown, inPlanMode, planAccepted, planRejected, agentLabel, lastPlanTs, planDurationMs, buildDraftingActivity());
  if (lastPlan) finalized.push(lastPlan);

  return finalized;
}

// ─── Dashboard builder ──────────────────────────────────────────────────────

/** Grace period: keep recently-dead sessions visible so feed/plans persist across context clears */
const RECENT_GRACE_MS = 24 * 60 * 60 * 1000; // 24 hours

export function buildDashboardState(): DashboardState {
  // 0. Load operator config
  const config = loadOperatorConfig();
  const selfName = getSelfName(config);

  // Build operator registry
  const operatorRegistry: Operator[] = [
    { id: "self", name: selfName, color: getOperatorColor(0), status: "offline" },
  ];
  for (let i = 0; i < config.operators.length; i++) {
    const op = config.operators[i];
    operatorRegistry.push({
      id: makeOperatorId(op.name),
      name: op.name,
      color: getOperatorColor(i + 1),
      status: "offline",
    });
  }

  // Session → operator mapping
  const sessionOperatorMap = new Map<string, string>();

  // 1. Get all active sessions (self)
  const activeSessions = getActiveSessions();
  const activeSessionIds = new Set(activeSessions.map(s => s.id));

  // Tag self sessions
  for (const s of activeSessions) {
    sessionOperatorMap.set(s.id, "self");
  }

  // 2. Include active sessions + recently-dead sessions from same projects
  const allSessions = new Map<string, SessionInfo>();
  for (const s of activeSessions) {
    allSessions.set(s.id, s);
  }

  const projects = listProjects();
  const now = Date.now();

  // For each project with active sessions, include recent inactive sessions
  const activeProjectPaths = new Set(activeSessions.map(s => s.projectPath));
  for (const project of projects) {
    if (!activeProjectPaths.has(project.decodedPath)) continue;
    const projectSessions = listSessions(project.encodedName);
    for (const s of projectSessions) {
      if (allSessions.has(s.id)) continue;
      if (now - s.modifiedAt.getTime() < RECENT_GRACE_MS) {
        allSessions.set(s.id, s);
        if (!sessionOperatorMap.has(s.id)) sessionOperatorMap.set(s.id, "self");
      }
    }
  }

  // Codex discovery (self) — fully isolated
  try {
    const codexActiveSessions = getActiveCodexSessions();
    const codexRecent = discoverCodexSessions(1);
    for (const s of [...codexActiveSessions, ...codexRecent]) {
      if (allSessions.has(s.id)) continue;
      allSessions.set(s.id, s);
      if (!sessionOperatorMap.has(s.id)) sessionOperatorMap.set(s.id, "self");
    }
    for (const s of codexActiveSessions) activeSessionIds.add(s.id);
  } catch { /* Codex failure — continue Claude-only */ }

  // 2b. Discover sessions from configured operators
  for (const op of config.operators) {
    const opId = makeOperatorId(op.name);
    try {
      // Claude sessions for this operator
      if (op.claude) {
        const opProjects = listProjects(op.claude);
        for (const project of opProjects) {
          const opSessions = listSessions(project.encodedName, op.claude);
          for (const s of opSessions) {
            if (allSessions.has(s.id)) continue;
            if (now - s.modifiedAt.getTime() < RECENT_GRACE_MS) {
              allSessions.set(s.id, s);
              sessionOperatorMap.set(s.id, opId);
            }
          }
        }
      }
      // Codex sessions for this operator
      if (op.codex) {
        const opCodexSessions = discoverCodexSessions(1, op.codex);
        for (const s of opCodexSessions) {
          if (allSessions.has(s.id)) continue;
          allSessions.set(s.id, s);
          sessionOperatorMap.set(s.id, opId);
        }
      }
    } catch { /* skip broken operator config */ }
  }

  // 3. Parse all sessions
  const parsedSessions: ParsedSession[] = [];
  const claudeParsedIds = new Set<string>();
  const codexSessionIds = new Set<string>();
  for (const session of allSessions.values()) {
    if (isCodexSession(session)) continue;
    try {
      parsedSessions.push(getCachedOrParse(session));
      claudeParsedIds.add(session.id);
    } catch {
      // Skip unparseable sessions
    }
  }

  // Parse Codex sessions
  for (const session of allSessions.values()) {
    if (claudeParsedIds.has(session.id)) continue;
    if (!isCodexSession(session)) continue;
    try {
      parsedSessions.push(getCachedOrParseCodex(session));
      codexSessionIds.add(session.id);
    } catch { /* skip broken Codex session */ }
  }

  // 4. Build session label map
  const labelMap = buildLabelMap(parsedSessions.map(p => p.session.id));

  // 5. Detect collisions (only between currently active sessions)
  const activeParsed = parsedSessions.filter(p => activeSessionIds.has(p.session.id));
  const collisions = detectCollisions(activeParsed, labelMap, sessionOperatorMap);
  const collisionFileSet = new Set(collisions.flatMap(c => c.agents.map(a => a.sessionId)));

  // 6. Build agents
  const agents: Agent[] = [];

  for (const parsed of parsedSessions) {
    const projectPath = parsed.session.projectPath;
    const label = labelMap.get(parsed.session.id) ?? parsed.session.id.slice(0, 8);
    const isActive = activeSessionIds.has(parsed.session.id);
    const status = determineAgentStatus(parsed, isActive, collisionFileSet);

    const lastTurn = parsed.turns[parsed.turns.length - 1];
    const currentTask = lastTurn?.summary ?? "idle";

    // Plans: fall back to accumulator if current parse lost them (compaction)
    const sessionAcc = accumulators.get(parsed.session.id);
    let plans = buildSessionPlans(parsed, label);
    if (plans.length === 0 && sessionAcc?.plans?.length) {
      plans = sessionAcc.plans.map(p => ({ ...p, agentLabel: label }));
    }

    // Risk: pass accumulated error history for trend continuity, and accumulated cost for compaction
    const risk = computeAgentRisk(parsed, sessionAcc?.errorHistory, sessionAcc?.totalCost);

    agents.push({
      sessionId: parsed.session.id,
      label,
      agentType: codexSessionIds.has(parsed.session.id) ? "codex" : "claude",
      status,
      currentTask,
      filesChanged: parsed.stats.filesChanged,
      projectPath,
      isActive,
      plans,
      risk,
      operatorId: sessionOperatorMap.get(parsed.session.id) ?? "self",
    });
  }

  // ─── Stall detection (post-pass, no existing code modified) ─────────
  const STALL_WARN_MS = 5 * 60 * 1000;   // 5 min → elevated
  const STALL_CRIT_MS = 15 * 60 * 1000;  // 15 min → critical

  for (const agent of agents) {
    if (!agent.isActive) continue;
    const session = allSessions.get(agent.sessionId);
    if (!session) continue;
    const silenceMs = now - session.modifiedAt.getTime();
    if (silenceMs > STALL_CRIT_MS) {
      agent.risk.spinningSignals.push({
        pattern: "stalled",
        level: "critical",
        detail: `No activity for ${Math.round(silenceMs / 60000)}m`,
      });
    } else if (silenceMs > STALL_WARN_MS) {
      agent.risk.spinningSignals.push({
        pattern: "stalled",
        level: "elevated",
        detail: `No activity for ${Math.round(silenceMs / 60000)}m`,
      });
    }
    // Recompute overallRisk if stall signal was injected
    if (agent.risk.spinningSignals.some(s => s.level === "critical")) {
      agent.risk.overallRisk = "critical";
    } else if (agent.risk.overallRisk === "nominal" && agent.risk.spinningSignals.some(s => s.level === "elevated")) {
      agent.risk.overallRisk = "elevated";
    }
  }

  // 7. Build workstreams (group by project)
  const projectGroups = new Map<string, ParsedSession[]>();
  for (const parsed of parsedSessions) {
    const key = parsed.session.projectPath;
    if (!projectGroups.has(key)) projectGroups.set(key, []);
    projectGroups.get(key)!.push(parsed);
  }

  const workstreams: Workstream[] = [];
  for (const [projectPath, sessions] of projectGroups) {
    const allProjectAgents = agents.filter(a => a.projectPath === projectPath);
    const activeProjectAgents = allProjectAgents.filter(a => a.isActive);
    let totalTurns = 0;
    let completedTurns = 0;
    let commits = 0;
    let errors = 0;

    for (const s of sessions) {
      totalTurns += s.turns.length;
      completedTurns += s.turns.filter(t => t.hasCommit).length;
      commits += s.stats.commits;
      errors += s.turns.filter(t => t.hasError).length;
    }

    const hasCollision = activeProjectAgents.some(a => a.status === "conflict");

    const plans = allProjectAgents.flatMap(a => a.plans).filter(p =>
      p.status !== "none"
      && p.status !== "rejected"
      && !(p.status === "drafting" && !p.markdown && !p.draftingActivity)
    );
    const planTasks = plans.flatMap(p => p.tasks);

    let completionPct: number;
    if (planTasks.length > 0) {
      const done = planTasks.filter(t => t.status === "completed").length;
      completionPct = Math.round((done / planTasks.length) * 100);
    } else {
      completionPct = totalTurns > 0 ? Math.round((completedTurns / totalTurns) * 100) : 0;
    }

    const project = projects.find(p => p.decodedPath === projectPath);
    const projectId = project?.encodedName ?? projectPath.replace(/\//g, "-");

    const risk = computeWorkstreamRisk(activeProjectAgents);

    workstreams.push({
      projectId,
      projectPath,
      name: basename(projectPath) || projectPath,
      agents: activeProjectAgents,
      completionPct,
      totalTurns,
      completedTurns,
      hasCollision,
      commits,
      errors,
      plans,
      planTasks,
      risk,
    });
  }

  // Sort workstreams: active first, then by name
  workstreams.sort((a, b) => {
    const aActive = a.agents.some(ag => ag.isActive);
    const bActive = b.agents.some(ag => ag.isActive);
    if (aActive !== bActive) return aActive ? -1 : 1;
    return a.name.localeCompare(b.name);
  });

  // 8. Build feed
  const feed = buildFeed(parsedSessions, collisions, labelMap, activeSessionIds, sessionOperatorMap);

  // 9. Build operators — set status to "online" if any agents are active
  const operatorActiveSet = new Set<string>();
  for (const agent of agents) {
    if (agent.isActive) operatorActiveSet.add(agent.operatorId);
  }
  const operators: Operator[] = operatorRegistry.map(op => ({
    ...op,
    status: operatorActiveSet.has(op.id) ? "online" as const : "offline" as const,
  }));

  // 10. Build summary — only active agents are exposed
  const activeAgents = agents.filter(a => a.isActive);
  const agentsAtRisk = activeAgents.filter(a => a.risk.overallRisk !== "nominal").length;
  const totalCost = activeAgents.reduce((sum, a) => sum + a.risk.costPerSession, 0);
  const summary: DashboardSummary = {
    totalAgents: activeAgents.length,
    activeAgents: activeAgents.length,
    totalCollisions: collisions.length,
    criticalCollisions: collisions.filter(c => c.severity === "critical").length,
    totalWorkstreams: workstreams.length,
    totalCommits: workstreams.reduce((sum, w) => sum + w.commits, 0),
    totalErrors: workstreams.reduce((sum, w) => sum + w.errors, 0),
    agentsAtRisk,
    operatorCount: operators.length,
    totalCost,
  };

  return { operators, agents: activeAgents, workstreams, collisions, feed, summary };
}

/** How long since last file modification before an active session is considered idle */
const IDLE_THRESHOLD_MS = 30_000; // 30 seconds

function determineAgentStatus(
  parsed: ParsedSession,
  isActive: boolean,
  collisionSessionIds: Set<string>
): AgentStatus {
  // Conflict: this session has files in a detected collision
  if (collisionSessionIds.has(parsed.session.id)) return "conflict";

  // Warning: errors in the last 3 turns
  const recentTurns = parsed.turns.slice(-3);
  if (recentTurns.some(t => t.hasError)) return "warning";

  // Active process but no recent file writes → idle (waiting for user input)
  if (isActive) {
    const mtime = parsed.session.modifiedAt.getTime();
    return Date.now() - mtime > IDLE_THRESHOLD_MS ? "idle" : "busy";
  }

  return "idle";
}
